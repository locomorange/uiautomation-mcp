using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace UIAutomationMCP.SourceGenerators
{
    /// <summary>
    /// Source generator for automatic operation registration
    /// </summary>
    [Generator]
    public class OperationRegistrationGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // Find all classes with AutoRegisterOperation attribute
            var operationClasses = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (node, _) => IsOperationClass(node),
                    transform: static (context, _) => GetOperationInfo(context))
                .Where(static info => info != null);

            // Generate registration code
            context.RegisterSourceOutput(
                operationClasses.Collect(),
                static (context, operations) => GenerateRegistrationCode(context, operations));
        }

        private static bool IsOperationClass(SyntaxNode node)
        {
            if (node is not ClassDeclarationSyntax classDeclaration)
                return false;

            // Check if class has AutoRegisterOperation attribute
            return classDeclaration.AttributeLists
                .SelectMany(list => list.Attributes)
                .Any(attr => attr.Name.ToString().Contains("AutoRegisterOperation"));
        }

        private static OperationInfo? GetOperationInfo(GeneratorSyntaxContext context)
        {
            if (context.Node is not ClassDeclarationSyntax classDeclaration)
                return null;

            var symbol = context.SemanticModel.GetDeclaredSymbol(classDeclaration);
            if (symbol == null)
                return null;

            // Check if it has AutoRegisterOperation attribute
            var hasAttribute = symbol.GetAttributes()
                .Any(attr => attr.AttributeClass?.Name == "AutoRegisterOperationAttribute");

            if (!hasAttribute)
                return null;

            // Find the base type to extract Request and Result types
            var baseType = symbol.BaseType;
            while (baseType != null)
            {
                if (baseType.IsGenericType && 
                    baseType.Name == "BaseUIAutomationOperation" &&
                    baseType.TypeArguments.Length == 2)
                {
                    var requestType = baseType.TypeArguments[0];
                    var resultType = baseType.TypeArguments[1];

                    return new OperationInfo(
                        symbol.Name,
                        requestType.Name,
                        resultType.Name,
                        symbol.ContainingNamespace.ToDisplayString(),
                        GetAssemblyName(symbol.ContainingNamespace.ToDisplayString()));
                }
                baseType = baseType.BaseType;
            }

            return null;
        }

        private static string GetAssemblyName(string namespaceName)
        {
            if (namespaceName.Contains("Worker"))
                return "Worker";
            if (namespaceName.Contains("Monitor"))
                return "Monitor";
            return "Unknown";
        }

        private static void GenerateRegistrationCode(SourceProductionContext context, ImmutableArray<OperationInfo?> operations)
        {
            var validOperations = operations.Where(o => o != null).Cast<OperationInfo>().ToList();

            var workerOperations = validOperations.Where(o => o.Assembly == "Worker").ToList();
            var monitorOperations = validOperations.Where(o => o.Assembly == "Monitor").ToList();

            if (workerOperations.Any())
            {
                var workerCode = GenerateAssemblyRegistration("Worker", workerOperations);
                context.AddSource("WorkerOperationRegistration.g.cs", workerCode);
            }

            if (monitorOperations.Any())
            {
                var monitorCode = GenerateAssemblyRegistration("Monitor", monitorOperations);
                context.AddSource("MonitorOperationRegistration.g.cs", monitorCode);
            }
        }

        private static string GenerateAssemblyRegistration(string assemblyName, List<OperationInfo> operations)
        {
            var sb = new StringBuilder();

            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
            sb.AppendLine("using UIAutomationMCP.Common.Abstractions;");
            sb.AppendLine("using UIAutomationMCP.Models.Requests;");
            
            // Add necessary using statements
            var namespaces = operations.Select(o => o.Namespace).Distinct().ToList();
            foreach (var ns in namespaces)
            {
                sb.AppendLine($"using {ns};");
            }

            sb.AppendLine();
            sb.AppendLine($"namespace UIAutomationMCP.{assemblyName}.Generated");
            sb.AppendLine("{");
            sb.AppendLine("    /// <summary>");
            sb.AppendLine($"    /// Auto-generated operation registration for {assemblyName} assembly");
            sb.AppendLine("    /// </summary>");
            sb.AppendLine("    public static class OperationRegistration");
            sb.AppendLine("    {");
            sb.AppendLine("        /// <summary>");
            sb.AppendLine("        /// Register all operations marked with AutoRegisterOperation attribute");
            sb.AppendLine("        /// </summary>");
            sb.AppendLine("        public static IServiceCollection RegisterAllOperations(this IServiceCollection services)");
            sb.AppendLine("        {");

            foreach (var operation in operations)
            {
                sb.AppendLine($"            // Register {operation.OperationType}");
                sb.AppendLine($"            services.AddKeyedTransient<IUIAutomationOperation, {operation.OperationType}>(");
                sb.AppendLine($"                new {operation.RequestType}().Operation);");
                sb.AppendLine();
            }

            sb.AppendLine("            return services;");
            sb.AppendLine("        }");
            sb.AppendLine("    }");
            sb.AppendLine("}");

            return sb.ToString();
        }

        private class OperationInfo
        {
            public string OperationType { get; }
            public string RequestType { get; }
            public string ResultType { get; }
            public string Namespace { get; }
            public string Assembly { get; }

            public OperationInfo(string operationType, string requestType, string resultType, string @namespace, string assembly)
            {
                OperationType = operationType;
                RequestType = requestType;
                ResultType = resultType;
                Namespace = @namespace;
                Assembly = assembly;
            }
        }
    }
}